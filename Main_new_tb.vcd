$date
	Sun Nov 13 23:54:27 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module Main_new_tb $end
$scope module uut $end
$var reg 1 ! hitmiss $end
$var reg 5 " hittag [4:0] $end
$var reg 28 # memoryAddress [27:0] $end
$var reg 1 $ readEnable $end
$var reg 5 % tagNumber [4:0] $end
$var reg 7 & temp [6:0] $end
$var reg 14 ' writeData [13:0] $end
$var reg 1 ( writeEnable $end
$var integer 32 ) addressToMemory [31:0] $end
$var integer 32 * blockNumberInMemory [31:0] $end
$var integer 32 + data [31:0] $end
$var integer 32 , empty [31:0] $end
$var integer 32 - file [31:0] $end
$var integer 32 . hitrate [31:0] $end
$var integer 32 / missmaxcount [31:0] $end
$var integer 32 0 offset [31:0] $end
$var integer 32 1 readhit [31:0] $end
$var integer 32 2 readmiss [31:0] $end
$var integer 32 3 set_number [31:0] $end
$var integer 32 4 statusi [31:0] $end
$var integer 32 5 way_number [31:0] $end
$var integer 32 6 way_number_temp [31:0] $end
$var integer 32 7 writehit [31:0] $end
$var integer 32 8 writemiss [31:0] $end
$scope begin $ivl_for_loop0 $end
$var integer 32 9 i [31:0] $end
$scope begin $ivl_for_loop1 $end
$var integer 32 : j [31:0] $end
$scope begin $ivl_for_loop2 $end
$var integer 32 ; k [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope begin $ivl_for_loop3 $end
$var integer 32 < i [31:0] $end
$scope begin $ivl_for_loop4 $end
$var integer 32 = j [31:0] $end
$upscope $end
$upscope $end
$scope begin $ivl_for_loop5 $end
$var integer 32 > z [31:0] $end
$scope begin $ivl_for_loop10 $end
$var integer 32 ? i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop11 $end
$var integer 32 @ i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop6 $end
$var integer 32 A i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop7 $end
$var integer 32 B i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop8 $end
$var integer 32 C i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop9 $end
$var integer 32 D i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10000 D
b1000 C
b1000 B
b11111111111111111111111111111111 A
b1000 @
b10000 ?
b10011100010000 >
b10000 =
b100000000 <
b10000 ;
b1000 :
b100 9
b1000011110101 8
b1000111100 7
b111 6
b11111111111111111111111111111111 5
b11 4
b100 3
b1000110000111 2
b1001011000 1
b1010 0
b11111111111111111111111111111111 /
b1011 .
b10000000000000000000000000000011 -
b11111111111111111111111111111111 ,
b0 +
b101100 *
b1101010 )
0(
b10011001001110 '
b1010000 &
b101 %
1$
b1001011001010 #
b100 "
0!
$end
#10
